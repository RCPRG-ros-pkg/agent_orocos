#!/usr/bin/python
import sys

import roslib

import gencpp
import genmsg

from  roslib import packages,msgs
import os

from cStringIO import StringIO

import argparse

import parse_subsystem_xml

def generate_boost_serialization(package, port_def, output_cpp):
    """
    Generate a boost::serialization header

    @param msg_path: The path to the .msg file
    @type msg_path: str
    """
    mc = genmsg.msg_loader.MsgContext()

    with open(port_def, 'r') as f:
        read_data = f.read()

    sd = parse_subsystem_xml.parseSubsystemXml(read_data)

    s = StringIO()
    s.write("// autogenerated by rtt_subsystem/create_master_h.py\n")
    s.write("// do not modify this file\n\n")

    header_name = package.upper() + "_MASTER_H__"
    s.write("#ifndef " + header_name + "\n")
    s.write("#define " + header_name + "\n\n")

    s.write("#include \"subsystem_common/input_data.h\"\n")
    s.write("#include <rtt/RTT.hpp>\n")
    s.write("#include \"subsystem_common/abstract_predicate_list.h\"\n\n")


    for p_in in sd.buffers_in:
        s.write("#include \"" + p_in.type_pkg + "/" + p_in.type_name + ".h\"\n")

    s.write("\nnamespace " + package + "_types {\n\n")

    #
    # class InputData
    #
    s.write("// Data structure used in predicates.\n//It contains data from all subsystem input buffers.\n")
    s.write("class InputData : public subsystem_common::InputData {\n")
    s.write("public:\n")

    for p_in in sd.buffers_in:
        s.write("  " + p_in.type_pkg + "::" + p_in.type_name + " " + p_in.alias + ";\n")
        s.write("  bool " + p_in.alias + "_valid;\n")

    s.write("};\n\n")

    s.write("typedef boost::shared_ptr<InputData > InputDataPtr;\n\n")
    s.write("typedef boost::shared_ptr<const InputData > InputDataConstPtr;\n\n")

    #
    # class PredicateList
    #

    s.write("class PredicateList : public subsystem_common::PredicateList {\n")
    s.write("public:\n")
    for pred in sd.predicates:
        s.write("  bool " + pred + ";\n")

    s.write("\n  virtual subsystem_common::PredicateList& operator=(const subsystem_common::PredicateList& arg);\n")

    s.write("};\n\n")

    s.write("typedef boost::shared_ptr<PredicateList > PredicateListPtr;\n\n")
    s.write("typedef boost::shared_ptr<const PredicateList > PredicateListConstPtr;\n\n")

    #
    # predicate function prototype
    #

    s.write("typedef bool (*predicateFunction)(\n")
    s.write("            const InputDataConstPtr&,\n")
    s.write("            const std::vector<const RTT::TaskContext*>&);\n\n")

    s.write("class PredicateFactory\n")
    s.write("{\n")
    s.write("private:\n")
    s.write("    std::map<std::string, predicateFunction > functionRegistry;\n\n")

    s.write("    PredicateFactory() {}\n\n")

    s.write("public:\n")

    s.write("    void RegisterFunction(const std::string &name, predicateFunction func)\n")
    s.write("    {\n")
    s.write("        // register the class factory function\n")
    s.write("        functionRegistry[name] = func;\n")
    s.write("    }\n\n")

    s.write("    const std::map<std::string, predicateFunction >& getPredicates() const {\n")
    s.write("        return functionRegistry;\n")
    s.write("    }\n\n")

    s.write("    predicateFunction getPredicate(const std::string &name) const {\n")
    s.write("        std::map<std::string, predicateFunction >::const_iterator it = functionRegistry.find( name );\n")
    s.write("        return it->second;\n")
    s.write("    }\n\n")

    s.write("    static PredicateFactory* Instance()\n")
    s.write("    {\n")
    s.write("        static PredicateFactory factory;\n")
    s.write("        return &factory;\n")
    s.write("    }\n")
    s.write("};\n\n")

    s.write("class PredicateRegistrar {\n")
    s.write("public:\n")
    s.write("    PredicateRegistrar(predicateFunction func, std::string func_name)\n")
    s.write("    {\n")
    s.write("        RTT::Logger::log() << RTT::Logger::Debug << \"PredicateRegistrar: \" << func_name << RTT::Logger::endl;\n")
    s.write("        // register the class factory function\n")
    s.write("        PredicateFactory::Instance()->RegisterFunction(func_name, func);\n")
    s.write("    }\n")
    s.write("};\n\n")

    s.write("#define LITERAL_registrar_predicate_(X) registrar_predicate_##X\n")
    s.write("#define EXPAND_registrar_predicate_(X) LITERAL_registrar_predicate_(X)\n\n")

    s.write("#define STRINGIFY(x) #x\n")
    s.write("#define TOSTRING(x) STRINGIFY(x)\n\n")

    s.write("#define REGISTER_PREDICATE( PREDICATE_FUNCTION ) static " + package + "_types::PredicateRegistrar EXPAND_registrar_predicate_(__LINE__)(PREDICATE_FUNCTION, TOSTRING(PREDICATE_FUNCTION))\n\n")

    s.write("};  // namespace " + package + "_types\n\n")

    s.write("#endif  // " + header_name + "\n")

    (output_dir,filename) = os.path.split(output_cpp)
    try:
        os.makedirs(output_dir)
    except OSError, e:
        pass

    f = open(output_cpp, 'w')
    print >> f, s.getvalue()

    s.close()


def create_boost_headers(argv, stdout, stderr):
    parser = argparse.ArgumentParser(description='Generate boost serialization header for ROS message.')
    parser.add_argument('pkg',metavar='PKG',type=str, nargs=1,help='The package name.')
    parser.add_argument('port_def',metavar='PORT_DEF',type=str, nargs=1,help='Port definition file.')
    parser.add_argument('output_cpp',metavar='OUTPUT_CPP',type=str, nargs=1,help='Output cpp file.')

    args = parser.parse_args()

    print args.pkg[0], args.port_def[0], args.output_cpp[0]

    generate_boost_serialization(args.pkg[0], args.port_def[0], args.output_cpp[0])

if __name__ == "__main__":
    try:
        create_boost_headers(sys.argv, sys.stdout, sys.stderr)
    except Exception, e:
        sys.stderr.write("Failed to generate boost headers: " + str(e))
        raise
        #sys.exit(1)
